// ЗАДАНИЯ ДЛЯ РАЗМИНКИ!!!!!!)))

// EXERCISE-1
// Есть функция a! Пояснить почему при вызове функции b возьмется k из функции b! Ну и предложить решение чтобы брать k которое выше!
// ANSWER:

function a(arg) {
  let k = 10;
  function b() {
    let k = 20;
    return k;
  }
  const res = b() + arg;
  return res;
}

a(1);

// 1
// Когда код хочет получить доступ к переменной - сначала происходит поиск во внутреннем лексическом окружении,
// затем во внешнем, затем в следующем, и так далее, до глобального.
// как мы видим, при вызове функции b возьмется k которая равна 20
// ибо она лежит во внутреннем лексическом окружении.

// 2
function a(arg) {
  let k = 10;
  function b() {
    // let k = 20; удаляем
    return k;
  }
  const res = b() + arg;
  return res;
}

a(1);

// Чтобы взять k которое выше, нужно удалить k лежащее в функции b.
// Тогда функция b будет замкнута на область видимости родительской функции a,
// и возьмёт k у которой значение 10.

// 3
function a(arg) {
  let k = 10;
  function b() {
    // let k = 20; удаляем
    return k;
  }
  const res = k + arg; // можно просто на характере заменить b() на k!!!)))
  return res;
}

a(1);

// EXERCISE-2
// Написать функцию которая принимает параметр num и вовращает новую функцию которая тоже принимет один параметр возвращает произведение!
// то num нужно замкнуть! 
// ANSWER:

function a(num) {
  return function(num1) {
    return num * num1;
  }
}

const res = a(5);

res(10); // 50

// EXERCISE-3
// Есть функция counter!Пояснить почему res, res1 берут разные i с замыкания!
// ANSWER:

function counter() {
  var i = 1;
  return function () { // (**)
    return i++;
  };
}

const res = counter(); 

res();

res();

const res1 = counter();

res1();

res1();

// для каждого вызова counter() создаётся новое лексическое окружение функции, 
// со своим собственным i. Так что, получившиеся функции res и res1 – независимы.
// можно сказать в res и res1 находятся независимые друг от друга функции выполняющие одно и то же действие, 
// в которых есть своя область видимости с замыканием,
// в замыкании могут хранится разные значения и замыкание формируется при вызове функции,
// если переменная не используется в дочерней функции, то она стирается с памяти после её выполнения.

// EXERCISE-4
// Есть функция с которую мы разбирали! Нужно переопредлить toString f чтобы не обращатся к свойству k, а после нажатия enter выводило результат!

function c(num) {
  f.k = 0;
  function f(num1) {
    f.k += f.k ? num1 : num + num1;
    return f;
  }
  return f;
}
c(5)(6)(1).k; // таким образом мы получали k которое хранит сумму!!
c(5)(6)(5); // нужно чтобы в консоле показало не тело функции а результат то есть ну/но переопределить toString

// ANSWER:

function c(num) {
  f.k = 0;
  function f(num1) {
    f.k += f.k ? num1 : num + num1;
    return f;
  }
  return f;
}

let s = c(5)(6)(1);

s.toString = function() {
  return this.k;
}

s.toString();

// EXERCISE-5
// Разомнем мозги пишем собственный reduce! 
// ANSWER:

function reduce(array, f, initial) {
  let prev = initial ? initial : array[0];
  let start = initial ? 0 : 1;
  for (let i = start; i < array.length; i++) {
    prev = f(prev, array[i]);
  }
  return prev;
}

reduce([5, 2, 5, 1, 6, 3, 6], (prev, curr) => prev + curr, 0);

// EXERCISE-6
// Взял задачу с нета! Обьяснить почему первая выведет 10, а 2 остальные 0!
// ANSWER:

/*1*/ 
function arrOfFunctions() {
  var functions = [];
  for (var i = 0; i < 10; i++) {
    var f = function () { // функция-стрелок
      alert(i); // выводит свой номер
    };
    functions.push(f);
  }
  return functions;
}

var res = arrOfFunctions();

res[0](); // стрелок выводит 10, а должен 0

// по окончанию цикла i будет равен 10 (из-за i++)
// функция f берёт i из глобальной области, когда цикл закончился i = 10,
// затем функция f вызывает i, а тот в свою очередь в глобальной области равен 10.
// для var существует одна глобальная переменная которая на каждой итерации будет меняться,
// и для всех var f будет 10.

/*2*/
function arrOfFunctions() {
  var functions = [];
  for (var i = 0; i < 10; i++) {
    (function (i) {
      var f = function () {
        alert(i);
      };
      functions.push(f);
    })(i);
  }
  return functions;
}

var res = arrOfFunctions();

res[0]();

// тут каждый итератор закрепляется в параметре i 
// вся суть в замыкании где каждая i берётся из цикла и передается в параметр самовызывающейся функции.
// в i передается сначала 0 потом 1, 2, 3 ... и до победного.
// По сути задача решается с помощью областей видимости в замыкании.

/*3*/ 
function arrOfFunctions() {
  var functions = [];
  for (let i = 0; i < 10; i++) {
    var f = function () {
      alert(i);
    };
    functions.push(f);
  }
  return functions;
}

var res = arrOfFunctions();

res[0]();

// тут в цикле инициализирован счётчик с помощью переменной let,
// а у неё в отличии от var есть блочная область видимости.
// Для каждой итерации будет создаваться свой let i, let i = 0; let i = 1 ... и т.д.
// ПОХОЖУЮ ЗАДАЧКУ Я ВИДЕЛ НА https://learn.javascript.ru/ В РАЗДЕЛЕ "ЗАМЫКАНИЕ".